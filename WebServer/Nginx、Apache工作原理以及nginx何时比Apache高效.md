# Nginx、Apache工作原理以及nginx何时比Apache高效

## 问题
网络上有好多 " nginx 性能高于、完爆 Apache " 的偏激或者片面言论；我相信 "存在即合理" ，Apache和nginx现在最常用的两种开源网络服务器，就意味着二者各有所长，都有各自存在的意义和原因。

本文主要是讨论一下nginx和Apache的工作原理，然后据此推理二者的优缺点，进而分析各自的适用场景

## 概览
在深入了解Apache和Nginx不同之前，简单的回顾下两个服务器软件的背景与特性。

Apache 服务器是1995年由 Robert McCool在Apache基金会的领导下开发出来的。因为Apache的灵活性，高性能和高扩展。它通常被系统管理员选择作为web服务器。它可以通过动态加载模块，来拓展功能，并且可以通过不连接其他第三方软件的情况下，执行多种解释型语言。

Nginx 在2002年，Igor Sysoev开始着手写Nginx服务器来解决C10K问题。C10K问题是Web服务器的一个挑战，要求同一个web服务器在同一时刻可以处理10000个连接请求，Nginx在2004年通过依靠异步事件驱动架构来实现这个目的，并且发布了它的初始版本

Nginx的流行，源于它轻量级资源使用率和它能够扩展到小型设备上。Nginx擅长快速处理静态内容，并且它旨在将动态请求传递給更适合这些目的的其他软件。

## 原理

### Apache

Apache在高负载的情况下表现的差强人意，原因是它需要运行新的进程，所以更加的消耗内存，同时，他还要产生新的线程来与其他的线程竞争CPU和内存。当进程的流量达到了管理员设置的上限时，Apache会拒绝新的连接。

Apache可以通过设置来运行pre－forked模式或者worker multi-process模式(MPM).当其他的用户连接时，两种方式都会创建新的进程。区别在于，pre-fork模式为每一个进程创建一个线程，用来处理一个用户的请求。worker模式也创建新的进程，但是每一个进程至少有一个线程，每一个线程用来处理单个用户的单个请求。所以一个worker mode的进程处理至少一个连接，而一个pre-fork模式的进程只处理一个连接。

在和nginx对比时，为降低问题复杂性，我们以默认的pre－forked模式来总结Apache的特点：

- **进程模型**：使用多进程的方式来处理并发。每当有新请求来临时或从空闲进程列表里取一个，或者创建一个新的进程，二者的区别不是特别大。

- **I/O 模型**：使用SELECT阻塞 I/O模型。调用SELECT阻塞，等待有 I/O 就绪时返回，返回之后线性扫描 SELECT 所监听的文件描述符列表找到就绪的描述符。

- **动态页面支持**：以PHP为例，Apache支持模块模式、cgi模式和fastcgi模式三种模式。


### Nginx
和Apache相比，Nginx的工作方式有很大不同，主要是在于它如何处理线程和 I/0 模型。

Nginx并不会为每一个Web请求创建新的进程，相反，管理员可以配置Nginx主进程的工作进程数量(一个常见的做法是为每一个CPU配置一个工作进程)。所有这些进程都是单线程的。每一个工作进程可以处理数千个并发请求。它通过一个线程来异步的完成这些工作，而没有使用多线程的编程模型。

Nginx还拆分了缓存加载器(Cache Loader)和缓存管理器(Cache Manager)进程用来从磁盘中读取数据，并将其加载到缓存中

Nginx有一系列的模块组成，这些模块在编译的时候，就被包含进去了。这些模块中包含连接后端应用服务器，负载均衡，代理服务器以及其他，并没有PHP模块

对应总结下nginx的特点：

- **进程模型**：使用固定数量的多worker进程模式，一般配置为CPU核数以充分利用CPU的并行能力。每个worker进程里只有一个线程以异步的方式

- **I/O 模型**：使用Epoll 异步非阻塞 I/O模型。调用Epoll添加监听 I/O 事件，当 I/O 就绪时通过回调设置就绪事件列表。调用epoll_wait等待有 I/O 就绪时返回就绪事件列表，扫描就绪事件列表，依次处理对应的连接。相比 SELECT 的优点：1. 数据结构不同，Epoll支持的FD上限是最大可以打开文件的数目；2. O的效率不会随着监视fd的数量的增长而下降。局限性：如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。

- **动态页面支持**：以PHP为例，Apache目前仅支持fastcgi模式。


### nginx设计哲学推断

> 本部分纯熟个人推断，如有谬误，还请各位评论指正

1. **个人认为，nginx的所有特性都始于epoll模型来实现的高效I/0多路复用。**

2. 因为具备了epoll这种高效的 I/O 复用模型，使得即使在单线程内处理高并发 I/O 成为可能，在一个请求因为 I/O 而导致 CPU 闲置时，可以转而处理另外一个请求。而 Apache 则是在当前请求因 I/O 阻塞时则挂起，通过操作系统的进程切换转而处理其它请求。

	在单核CPU的情况下，无论增加多少线程，某一时刻运行的线程只有一个。多线程多进程性能更好的原因不外乎是在当前进程 I/0 繁忙的时候让出 CPU，让 CPU 处理另一个请求。在有了高效的非阻塞异步 I/O 复用 epoll 之后，在一个线程里就可以处理好 I/O 和并发的关系，还避免了线程调度的上下文切换。因此 nginx 采用了单线程模型，多 worker 进程也只是在此基础上最大限度的利用多核CPU的并行能力。

3. **访问静态资源时nginx比Apache更高效**。从以上两点可以得出**nginx在处理I/O繁忙的业务方面具有优势**，又因为处理静态页面时，基本全是磁盘和网络I/O的消耗，而只需要很少的CPU资源，因此此时nginx更高效。

4. 动态内容分析。动态内容更倾向于消耗CPU资源，一次请求种 CPU 消耗占比相对提高，此时 nginx 善于处理高并发 I/O 的优点就不是那么重要了，因此我们说 nginx 不擅长处理动态内容。

	而事实上 nginx 作为一个轻量级 web 服务器本身并不支持动态内容处理，而是通过 CGI/fastCGI 模式与其它模块一起来实现动态内容处理。这里可以讲 CGI 接口作为一个 I/O 来处理。可以总结为：nginx 只做自己擅长的事，将不擅长的事交给其他人做，这也是 nginx 轻量级的体现。

	因此可以推出，**当nginx和Apache都采用fastcgi模式时，依旧是nginx更高效**；当Apache使用模块模式时，因为可以在Apache进程内部处理PHP文件，而不需要传递环境变量，与CGI接口通信，因而此时Apache可能更好一些。但这也不是绝对的，在高并发情况下，Apache仍然要付出频繁切换进程的开销以及相对低效的I/O。通过查阅资料可知，二者在处理动态内容方面性能差距不大，但因为Apache有更好的动态内容处理能力，不需要与第三方通信，相对来说更稳定一些。

## 比较

### nginx
- 轻量级，占用更少的内存与资源
	
	> 以**单线程 、较少的进程（进程数量一般设置为机器的CPU核数）**的模式运行，轮询I/O时避免了扫描整个文件描述符表。因而，相同并发下CPU有效利用率高，进程管理开销降低，进程管理所需的内存也就降低了
	
	> 只做自己擅长的事儿，专注做高并发下的 I/O 处理
	
- 抗高并发，负载能力比 Apache 高很多。在高并发下Nginx能够保持低资源低消耗高性能，而 Apache 在 PHP 处理慢或者前端压力很大的时候（一个进程处理一个请求或有限数量的请求），很容易出现进程数飙升，从而拒绝服务的情况。
	
	> Nginx 以 epoll and kqueue 作为开发模型，处理请求异步非阻塞，而 Apache 则是阻塞型。因此，当并发上升到一定程度时，Apache会因为阻塞导致单个进程和线程CPU利用率低，而并发所需的CPU算力又是一定的情况下，Apache需要提高进程和线程数才能应对同样的并发。虽然 linux 上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以并发能力不如 nginx。
	 
- Nginx处理静态文件的能力比Apache高出三倍以上。
	> nginx复用I/O能力更强，因此处理静态文件的能力更高
	
- Nginx的设计高度模块化，编写模块相对简单。
	> 只为高效处理 I/O，没有多线程，不涉及调度管理，逻辑相对简洁
- Nginx 配置简洁，正则配置让很多事情变的简单，而且改完配置能够使用 -t测试配置是否有问题，Apache配置复杂。
	> 由于设计简单，轻量化，因而需要配置的项比较少，配置出错的可能性相对也小
- Nginx 作为负载均衡服务器，支持7层负载均衡
	> 作为负载均衡时，将代理服务器看作 nginx 的网络 I/O 即可，从设计上更契合。
- Nginx本身是一个反响代理服务器，而且可以作为非常优秀的邮件代理服务器。
	> 分析同上一条负载均衡
- 容易启动，并且能够做到7*24不间断运行，即使运行数月也不需要重新启动，还能够不间断服务的情况下进行软件的版本升级
	> 工程实现



## 总结
两者核心区别在于Apache是同步多进程模型，一个连接对应一个进程，而Nginx是异步的，多个连接可以对应一个进程

一般来说，要求高并发的Web服务器，使用Nginx。

处理静态内容时，使用Nginx。

处理动态内容时；要求高并发，使用nginx + fastCGI；不要求高并发，使用Apache + 对应的动态处理模块，这种模式维护起来相对简单，更稳定一些。


**epoll(freebsd 上是kqueue) 网络IO模型是Nginx处理性能高的根本理由**，但是当如果本身提供的静态服务就只有几个文件，Apache的select 模型或许比epoll更高性能。

